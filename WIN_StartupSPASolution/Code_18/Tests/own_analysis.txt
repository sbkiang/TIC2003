for relationship
	-> if input is synonym and synonym is in select, will need to match sqlResultStore specific synonym
		similar to select a such that uses(a,"x")
			old code is for each "a", check if uses(a,"x") is true = filter by "a". Since "a" is specific, it is like matching each query with sqlResultStore
			new code is for each "a", check if each sqlResult in sqlResultStore of uses(a,"x") has the same "a" value
	
	-> if input is synonym and synonym is not in select, check if has result?
		select v1,v2 such that modifies("x","y")
			old code is for each "v1,v2", check if modifies("x","y"). Since modifies("x","y") is specific but no synonym, the final effect is similar to checking if relationship is true
			but, this causes issue in select a such that uses(3,v) pattern a(v,_"i"_) because "a" shud only be statements that passes uses(3,v). 
			so, can't simply use whether has result or not result to determine pass or fail. need to filter by common column type = statement match statement, procedure match procedurem, variable match variable
			
			modifies("x","y") return line_num and variable. Since there's variable column type, will check if it's match for v1,v2. but this will filter v1,v2
			
			
			for each synonym in select, if used in relationship, then there'll be a matching column
										if not used in relationship, then there may be matching column. but it doesn't matter
										
			select a such that uses(3,v) pattern a(v,_"i"_)
				check line_num with pattern ok for this cos "a" is line_num
				 
			select v such that uses(3,v) pattern a(v,_"i"_)
				check line_num with pattern fail cos "v" is not line_num, unless i get it
				if not based on line_num, then all "v" will pass cos uses(3,v) is true.
				then, it'll get all "v" that has %i% on RHS. So, the "v" isn't linked to uses(3,v) which is wrong. i need then to be linked
				
			select v such that uses(3,"ab") pattern a(v,_"i"_)
				assume uses(3,"ab") is true, all "v" passes. Then 
				
			
			relationship is filter based on "there exists"
			pattern is a filter based on?
			
			query2a
			Select v such that Modifies(a, v) pattern a1("z", _)
			i, x, y, z, bx
				here, no link also. so, return all v cos both "there exists" are true
			
			Select s such that Modifies(s, _) pattern a(v, _"10"_)
			1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15
				here, there's no link because modifies doesn't use "v"
				so, pattern functions as "there exists"?
				seems to be the case
			
			query2c
			Select v such that Modifies(a, v) pattern a1(v, _"i"_)
			i, y, z
			
			query2a
			Select a such that Uses(3, v) pattern a(v, _"i"_)
			6, 9, 14, 19, 24, 31
				v is reused for pattern? so is x or i on LHS, %i% on RHS
				even if we pass in individual line_num, it won't work. I need to linkup the common synonym in uses and pattern
				
			query2c
			Select v such that Uses(a, v) pattern a(_, _"a"_)
			a,b,c
				no link. Uses(a, v) is true. so, all v passes. pattern a(_, _"a"_) is true. all passes
				
			query2c
			Select v such that Modifies(w, v) pattern a(v, _"c"_)
			a
				have link. v will be the output of Modifies(w, v) = all variables on LHS in while container
					a, 
					
			query2c		
			Select v such that Parent*(w, a) pattern a(v, _"b"_)
			a, c, d
				no link for v. assume pattern function like exists, then all v passes = a,b,c,d
				then, test each v in pattern, a,d,c
			
			query2a
			Select a pattern a(v, _)
			1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 16, 17, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29, 30, 31, 32, 33
			does pattern alone function like there exists?
			
			query2c
			Select v pattern a(v, _"10"_)
			a
			
			select p pattern a(v, _"10"_)
			
			
										